
# Reading Values From The Stack: Format String Vulnerability Tutorial

## Introduction

This tutorial demonstrates how to exploit a format string vulnerability to read a specific value from memory.

## Understanding the Vulnerable Program

Let's examine the vulnerable program:

```c
#include <stdio.h>
#include <stdlib.h>

void print_flag() 
{
  printf("flag{YOU_FOUND_IT}\n");
}

void vulnerable_function() {
    long int x = 0xDEADBEEFDEADBEEF;
    char buffer[100];
    
    // Get some user input
    printf("Enter some text: ");
    fgets(buffer, sizeof(buffer), stdin);
    
    // Vulnerable line - directly using user input as format string
    printf(buffer);
    
    printf("\n");
}

int main() {
    printf("This program demonstrates a format string vulnerability.\n");
    
    vulnerable_function();
    
    return 0;
}
```

The vulnerability exists in the `vulnerable_function()` where user input is directly passed to `printf()` without any format specifier:

```c
printf(buffer);  // Vulnerable line
```

## How Format String Vulnerabilities Work

When `printf()` is called, it expects its first parameter to be a format string containing format specifiers (like `%d`, `%s`, `%x`, etc.). These specifiers tell `printf()` how to interpret and display the subsequent parameters.

If an attacker can control the format string, they can use format specifiers to:
1. Read data from the stack or other memory locations using `%x`, `%p`, `%s`, etc.
2. Write data to arbitrary memory locations using `%n` and its variants

## Exploiting the Vulnerability to Read Memory

Our goal is to read the value of variable `x` which contains `0xDEADBEEFDEADBEEF`.

### Step 1: Locate the Target Value in Memory

We'll first use multiple `%p` format specifiers to print values from the stack to locate where our target value is stored:

```
%p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p
```

When you enter this into the program, you'll see output similar to:

```
0x7ffff7ff6063 0x7ffff7bc9a10 ... 0xdeadbeefdeadbeef ... (more addresses)
```

We need to identify which position contains our target value `0xDEADBEEFDEADBEEF`.

### Step 2: Access the Specific Memory Location

Once we've identified the position of our target value, we can use the direct parameter access feature of format strings to read just that value.

For example, if the byte we want to read is byte X we can use %X$p

<details>
<summary>Click to reveal the format string for reading the memory value</summary>
For example, if our target value is at position 19, we can use:
  
```
%19$p
```
</details>

This format specifier uses the `$` syntax to directly access the 19th parameter, displaying only the target value instead of all preceding values.

## Format String Specifiers Reference

Here's a table of common format specifiers for reference:

|Parameter|Meaning|Passed as|
|---------|-------|----------|
| %d | decimal (int) | value |
| %u | unsigned decimal (unsigned int) | value |
| %x | hexadecimal (unsigned int) | value |
| %s | string ((const) (unsigned) char *) | reference |
| %n | number of bytes written so far, (* int) | reference |
| %c | character (unsigned char) | value |
| %p | pointer | value |
| %ld | long decimal (long) | value |
| %lx | long hexadecimal (unsigned long) | value |

